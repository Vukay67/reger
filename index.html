<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Title</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="warning-overlay">
        <div>
            <p>Это учебный сайт.</p>
            <button onclick="hideWarning()">Продолжить</button>
        </div>
    </div>
    
    <div class="main-content">
        <div class="d2">
            <pre><code>
# Ввод координат клеток
x1, y1 = map(int, input("Введите координаты первой клетки (x1 y1): ").split())
x2, y2 = map(int, input("Введите координаты второй клетки (x2 y2): ").split())
# Определяем цвета клеток по четности суммы координат
if (x1 + y1) % 2 == (x2 + y2) % 2:
    print("YES")
else:
    print("NO")
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
 # Ввод координат клеток
x1, y1 = map(int, input("Введите координаты первой клетки (x1 y1): ").split())
x2, y2 = map(int, input("Введите координаты второй клетки (x2 y2): ").split())
# Проверяем, может ли король сделать ход
if abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1:                                         >
    print("YES")
else:
    print("NO")
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111	
 # Ввод двух целых чисел A и B
A = int(input("Введите число A: "))
B = int(input("Введите число B: "))

# Вывод всех чисел от A до B включительно
for num in range(A, B + 1):
    print(num)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111	
# Ввод количества чисел N
N = int(input("Введите количество чисел: "))

# Инициализация переменной для суммы
total_sum = 0

# Ввод N целых чисел и их сумма
for _ in range(N):
    num = int(input("Введите целое число: "))
    total_sum += num  # Добавляем текущее число к сумме

# Вывод суммы
print("Сумма чисел:", total_sum)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
# Ввод строки
input_string = input("Введите строку: ")

# Вывод третьего символа
if len(input_string) >= 3:
    print(input_string[2])
else:
    print("Ошибка: строка слишком короткая.")

# Вывод предпоследнего символа
if len(input_string) >= 2:
    print(input_string[-2])
else:
    print("Ошибка: строка слишком короткая.")
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
# Ввод строки
input_string = input("Введите строку: ")

# Удаляем начальные и конечные пробелы и считаем количество пробелов
word_count = input_string.strip().count(' ') + 1 if input_string.strip() else 0

# Вывод количества слов
print("Количество слов в строке:", word_count)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
# Ввод строки
input_string = input("Введите строку из двух слов: ")

# Разделяем строку на слова и переставляем их местами
result_string = ' '.join(input_string.split()[::-1])

# Вывод результата
print(result_string)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
# Ввод числа
number = input("Введите целое неотрицательное число (до 5 цифр): ")

# Проверка на количество цифр
if len(number) > 5 or not number.isdigit():
    print("Ошибка: число должно быть неотрицательным и состоять не более чем из 5 цифр.")
else:
    # Нахождение максимальной цифры
    max_digit = max(number)

    # Подсчет количества вхождений максимальной цифры
    count_max_digit = number.count(max_digit)

    # Вывод результата
    print("Максимальная цифра:", max_digit)
    print("Количество вхождений максимальной цифры:", count_max_digit)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
	import math

# Ввод количества ребят в каждом отряде
groups = []
for _ in range(4):
    num = int(input("Введите количество ребят в отряде (10-25): "))
    if 10 <= num <= 25:                                                                   >
        groups.append(num)
    else:
        print("Ошибка: количество ребят должно быть от 10 до 25.")
        exit()

# Ввод количества математиков, физиков и информатиков
m = int(input("Введите количество математиков: "))
p = int(input("Введите количество физиков: "))
i = int(input("Введите количество информатиков: "))

# Ввод вместимости автобуса
n = int(input("Введите вместимость автобуса: "))

# Подсчет количества автобусов для каждой группы
buses_for_math = math.ceil(m / n)
buses_for_physics = math.ceil(p / n)
buses_for_info = math.ceil(i / n)

# Общее количество автобусов
total_buses = buses_for_math + buses_for_physics + buses_for_info

# Вывод результата
print("Минимальное количество автобусов:", total_buses)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def decode_password(s):
    result = []
    i = 0
    while i < len(s):                                                                           
        count = 1
        # Считаем количество одинаковых символов подряд
        while i + 1 < len(s) and s[i] == s[i + 1]:                                               >
            count += 1
            i += 1
        # Добавляем в результат строку, которая состоит из цифры (символ) и количества повторений
        result.append(str(count))
        i += 1
    return ''.join(result)

# Ввод пароля
s = input().strip()
print(decode_password(s))
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
from collections import defaultdict

# Список слов, соответствующих числам
words = ['бир', 'эки', 'үч', 'төрт', 'беш', 'алты', 'жети', 'сегиз', 'тогуз', 'он']

# Функция для нахождения минимальной суммы
def find_min_sum(s):
    # Шаг 1: Преобразуем слово в список букв
    letters = set(s)  # Получаем уникальные буквы
    if len(letters) > 10:
        return 1  # Если уникальных букв больше 10, это невозможно
    
    # Шаг 2: Собираем возможные буквы в минимальное значение
    letter_to_digit = {}
    available_digits = list(range(10))  # Возможные цифры от 0 до 9
    
    # Шаг 3: Присваиваем цифры буквам
    for letter in letters:
        letter_to_digit[letter] = available_digits.pop(0)  # Присваиваем минимальную доступную цифру
    
    # Шаг 4: Формируем число из букв
    number = 0
    for letter in s:
        number = number * 10 + letter_to_digit[letter]
    
    return number

# Вводим слово
s = input().strip()

# Вызов функции для нахождения минимальной суммы
result = find_min_sum(s)

# Выводим результат
print(result)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
MOD = 10**9 + 7

def solve():
    N = int(input())  # Количество операций
    result = 1  # Начинаем с числа 1
    last_op = None  # Для хранения последней операции (для R)
    
    for _ in range(N):
        op, X = input().split()
        X = int(X)
        
        if op == 'A':  # Прибавить X
            result = (result + X) % MOD
            last_op = ('A', X)  # Запоминаем операцию
        elif op == 'S':  # Вычесть X
            result = (result - X) % MOD
            last_op = ('S', X)  # Запоминаем операцию
        elif op == 'M':  # Умножить на X
            result = (result * X) % MOD
            last_op = ('M', X)  # Запоминаем операцию
        elif op == 'R':  # Повторить предыдущую операцию X раз
            if last_op:
                # Применяем последнюю операцию X раз
                last_op_type, last_op_value = last_op
                for _ in range(X):
                    if last_op_type == 'A':
                        result = (result + last_op_value) % MOD
                    elif last_op_type == 'S':
                        result = (result - last_op_value) % MOD
                    elif last_op_type == 'M':
                        result = (result * last_op_value) % MOD
    
    print(result)

# Запускаем решение
solve()
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def is_palindrome(n):
    # Преобразуем число в строку и проверяем, равно ли оно своему перевернутому варианту
    return str(n) == str(n)[::-1]

def count_palindromes(A, B):
    count = 0
    for num in range(A, B + 1):
        if is_palindrome(num):
            count += 1
    return count

# Чтение входных данных
A, B = map(int, input().split())

# Вывод результата
print(count_palindromes(A, B))
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def max_possible_value(replacements, word):
    # Заданный список слов
    words = ["BIR", "EKI", "VCH", "TQRT", "BESH", "ALTY", "JETI", "SEGIZ", "TOGUZ", "ON"]
    
    # Создаем список значений для этих слов
    values = {
        "BIR": 1, "EKI": 2, "VCH": 3, "TQRT": 4, "BESH": 5, "ALTY": 6,
        "JETI": 7, "SEGIZ": 8, "TOGUZ": 9, "ON": 10
    }
    
    # Функция для подсчета количества различий между двумя словами
    def count_diff(word1, word2):
        return sum(1 for a, b in zip(word1, word2) if a != b)
    
    # Переменная для хранения наибольшего возможного значения
    max_value = 0
    
    # Пробуем каждое слово в списке
    for w in words:
        # Если длина слов одинаковая и можно получить слово с помощью нужного количества замен
        if len(w) == len(word) and count_diff(w, word) <= replacements:                        >
            # Обновляем максимальное значение
            max_value = max(max_value, values[w])
    
    return max_value

# Ввод данных
replacements, word = input().split()
replacements = int(replacements)

# Получение результата
result = max_possible_value(replacements, word)

# Вывод результата
print(result)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def solve_equation(K, M, N):
    # Начнем проверку с X = 1 и будем увеличивать
    X = 1
    
    # Ограничение по X: попробуем искать до N (с учетом роста X^K)
    while True:
        # Вычисляем левую часть уравнения
        left_side = X**K + M * X
        
        # Если левая часть больше правой, можно остановиться, решение не существует
        if left_side > N:
            break
        
        # Если левая часть равна правой, нашли решение
        if left_side == N:
            return X
        
        # Увеличиваем X
        X += 1
    
    # Если не нашли решение, возвращаем 0
    return 0

# Ввод данных
K, M, N = map(int, input().split())

# Вывод результата
print(solve_equation(K, M, N))
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def min_coins(S1, S3, S5, S10, B):
    # Массив для хранения минимального числа монет для каждой суммы
    INF = float('inf')  # Бесконечность
    dp = [INF] * (B + 1)  # Инициализируем массив
    dp[0] = 0  # Для суммы 0 монет не нужно
    
    # Обрабатываем каждую монету
    for value, count in [(1, S1), (3, S3), (5, S5), (10, S10)]:
        for _ in range(count):  # Для каждого количества монет данного номинала
            for i in range(B, value - 1, -1):  # Идем в обратном порядке
                if dp[i - value] != INF:
                    dp[i] = min(dp[i], dp[i - value] + 1)
    
    # Если для суммы B существует решение, то возвращаем минимальное количество монет
    return dp[B] if dp[B] != INF else 0

# Ввод данных
S1, S3, S5, S10, B = map(int, input().split())

# Вывод результата
print(min_coins(S1, S3, S5, S10, B))
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
def needed_cubes(K, cubes):
    # Защищаемая точка
    target = (1, 1)

    # Список для хранения координат кубов, которые перекрывают точку (1, 1)
    covered = []

    # Проверка, какие кубы защищают точку (1, 1)
    for cube in cubes:
        x, y, z = cube
        # Куб защищает точку (1, 1), если его центр находится в пределах диапазона
        if abs(x - target[0]) <= 1 and abs(y - target[1]) <= 1:
            covered.append(cube)

    # Если точка уже защищена, то нет нужды в дополнительных кубах
    if len(covered) > 0:
        return 0, 0
    
    # В противном случае: находим количество дополнительных кубов
    # Для упрощения задачи, будем считать, что каждый куб защищает 1 единицу площади
    # Оценим, сколько кубов нужно для полной защиты точки
    # В данном контексте, нам нужно все 6 кубов

    return 6 - len(covered), len(covered)


# Ввод данных
K = int(input())  # Количество кубов
cubes = []
for _ in range(K):
    x, y, z = map(int, input().split())
    cubes.append((x, y, z))

# Вывод результата
print(*needed_cubes(K, cubes))
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
# Ввод
N = int(input())

# Ответ — это просто N, так как мы читаем слово "УЛУУ" N раз подряд
print(N)
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
            </code></pre>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>

